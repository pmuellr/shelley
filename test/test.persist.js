// Generated by CoffeeScript 1.3.3
(function() {
  var Backbone, Point, Storage, attrx, unexpectedError,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Backbone = require("backbone");

  Storage = require("shelley/persist/ModelLocalStorageSync");

  attrx = require("shelley/attrx");

  Point = (function(_super) {

    __extends(Point, _super);

    function Point() {
      return Point.__super__.constructor.apply(this, arguments);
    }

    attrx.declareAttributes(Point, {
      x: {
        type: Number
      },
      y: {
        type: Number
      }
    });

    Point.prototype.isPoint = function() {
      return true;
    };

    return Point;

  })(Backbone.Model);

  unexpectedError = function(model, e) {
    throw new Error("should not have errored with " + e);
  };

  describe("persist", function() {
    var point12;
    point12 = null;
    beforeEach(function() {
      return point12 = new Point({
        x: 1,
        y: 2
      });
    });
    afterEach(function() {});
    it("should handle new models", function() {
      var createdModel, createdModelCB, waiter;
      point12.sync = Storage.sync("test-1");
      createdModel = null;
      createdModelCB = function(model, attrs) {
        return createdModel = model;
      };
      runs(function() {
        return point12.save(null, {
          error: unexpectedError,
          success: createdModelCB
        });
      });
      waiter = function() {
        return createdModel;
      };
      waitsFor(waiter, "The model should have been created", 1000);
      return runs(function() {
        expect(createdModel.x).toEqual(point12.x);
        expect(createdModel.y).toEqual(point12.y);
        return expect(createdModel.isPoint()).toEqual(true);
      });
    });
    it("should handle fetching a saved model", function() {
      var fetchedModel, fetchedModelCB, point, waiter;
      point = new Point;
      point.sync = Storage.sync("test-1");
      fetchedModel = null;
      fetchedModelCB = function(model, attrs) {
        return fetchedModel = model;
      };
      runs(function() {
        return point.fetch({
          error: unexpectedError,
          success: fetchedModelCB
        });
      });
      waiter = function() {
        return fetchedModel;
      };
      waitsFor(waiter, "The model should have been fetched", 1000);
      return runs(function() {
        expect(fetchedModel.x).toEqual(point12.x);
        expect(fetchedModel.y).toEqual(point12.y);
        return expect(fetchedModel.isPoint()).toEqual(true);
      });
    });
    it("should handle updating a model", function() {
      var fetchedModelCB, point, updatedModel, updatedModelCB, waiter;
      point = new Point;
      point.sync = Storage.sync("test-1");
      updatedModel = null;
      fetchedModelCB = function(model, attrs) {
        model.x = 3;
        return model.save(null, {
          error: unexpectedError,
          success: updatedModelCB
        });
      };
      updatedModelCB = function(model, attrs) {
        return updatedModel = model;
      };
      runs(function() {
        return point.fetch({
          error: unexpectedError,
          success: fetchedModelCB
        });
      });
      waiter = function() {
        return updatedModel;
      };
      waitsFor(waiter, "The model should have been updated", 1000);
      return runs(function() {
        expect(updatedModel.x).toEqual(3);
        expect(updatedModel.y).toEqual(point12.y);
        return expect(updatedModel.isPoint()).toEqual(true);
      });
    });
    return it("should handle deleting a model", function() {
      var deletedModel, deletedModelCB, fetchedModelCB, point, waiter;
      point = new Point;
      point.sync = Storage.sync("test-1");
      deletedModel = null;
      fetchedModelCB = function(model, attrs) {
        return model.destroy({
          error: unexpectedError,
          success: deletedModelCB
        });
      };
      deletedModelCB = function(model, attrs) {
        return deletedModel = model;
      };
      runs(function() {
        return point.fetch({
          error: unexpectedError,
          success: fetchedModelCB
        });
      });
      waiter = function() {
        return deletedModel;
      };
      waitsFor(waiter, "The model should have been updated", 1000);
      return runs(function() {
        return expect(window.localStorage.getItem("test-1")).toBeNull();
      });
    });
  });

}).call(this);
