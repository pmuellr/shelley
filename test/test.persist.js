// Generated by CoffeeScript 1.3.3
(function() {
  var Backbone, LocalStorage, Point, unexpectedError,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  require("shelley");

  Backbone = require("backbone");

  LocalStorage = require("shelley/persist/LocalStorage");

  Point = (function(_super) {

    __extends(Point, _super);

    function Point() {
      return Point.__super__.constructor.apply(this, arguments);
    }

    Point.prototype.isPoint = function() {
      return true;
    };

    Point.prototype.toString = function() {
      return "" + this.constructor.name + (JSON.stringify(this.attributes));
    };

    return Point;

  })(Backbone.Model);

  unexpectedError = function(e) {
    throw new Error("should not have errored with " + e);
  };

  describe("persist", function() {
    beforeEach(function() {});
    afterEach(function() {});
    it("should handle new collections", function() {
      var coll, createdModel, createdModelCB, point, waiter;
      coll = new Backbone.Collection(null, {
        model: Point
      });
      coll.storage = new LocalStorage({
        name: "test-1"
      });
      point = {
        x: 1,
        y: 2
      };
      createdModel = null;
      createdModelCB = function(model) {
        return createdModel = model;
      };
      runs(function() {
        return coll.create(point, {
          error: unexpectedError,
          success: createdModelCB
        });
      });
      waiter = function() {
        return createdModel;
      };
      waitsFor(waiter, "The model should have been created", 1000);
      return runs(function() {
        expect(createdModel.get("x")).toEqual(point.x);
        return expect(createdModel.get("y")).toEqual(point.y);
      });
    });
    it("should handle fetching a saved collection", function() {
      var coll, createdModelCB, fetchedCollCB, point, restoredColl, waiter;
      coll = new Backbone.Collection(null, {
        model: Point
      });
      coll.storage = new LocalStorage({
        name: "test-2"
      });
      point = {
        x: 1,
        y: 2
      };
      restoredColl = null;
      createdModelCB = function(model) {
        expect(model.get("x")).toEqual(point.x);
        return coll.fetch({
          error: unexpectedError,
          success: fetchedCollCB
        });
      };
      fetchedCollCB = function(coll) {
        return restoredColl = coll;
      };
      runs(function() {
        return coll.create(point, {
          error: unexpectedError,
          success: createdModelCB
        });
      });
      waiter = function() {
        return restoredColl;
      };
      waitsFor(waiter, "The collection should have been fetched", 1000);
      return runs(function() {
        expect(restoredColl.at(0).get("x")).toEqual(point.x);
        return expect(restoredColl.at(0).get("y")).toEqual(point.y);
      });
    });
    it("should handle updating an item", function() {
      var coll, createdModelCB, fetchedCollCB, point, restoredColl, updatedModelCB, waiter;
      coll = new Backbone.Collection(null, {
        model: Point
      });
      coll.storage = new LocalStorage({
        name: "test-3"
      });
      point = {
        x: 1,
        y: 2
      };
      restoredColl = null;
      createdModelCB = function(model) {
        expect(model.get("x")).toEqual(point.x);
        model.set("x", 3);
        return model.save(null, {
          error: unexpectedError,
          success: updatedModelCB
        });
      };
      updatedModelCB = function(model) {
        expect(model.get("x")).toEqual(3);
        return coll.fetch({
          error: unexpectedError,
          success: fetchedCollCB
        });
      };
      fetchedCollCB = function(coll) {
        return restoredColl = coll;
      };
      runs(function() {
        return coll.create(point, {
          error: unexpectedError,
          success: createdModelCB
        });
      });
      waiter = function() {
        return restoredColl;
      };
      waitsFor(waiter, "The collection should have been updated", 1000);
      return runs(function() {
        expect(restoredColl.length).toEqual(1);
        expect(restoredColl.at(0).get("x")).toEqual(3);
        return expect(restoredColl.at(0).get("y")).toEqual(point.y);
      });
    });
    return it("should handle deleting an item", function() {
      var coll, createdModelCB, deletedModelCB, fetchedCollCB, point, restoredColl, waiter;
      coll = new Backbone.Collection(null, {
        model: Point
      });
      coll.storage = new LocalStorage({
        name: "test-4"
      });
      point = {
        x: 1,
        y: 2
      };
      restoredColl = null;
      createdModelCB = function(model) {
        return model.destroy({
          error: unexpectedError,
          success: deletedModelCB
        });
      };
      deletedModelCB = function(model) {
        expect(model.get("x")).toEqual(point.x);
        expect(model.get("y")).toEqual(point.y);
        expect(coll.length).toEqual(0);
        return coll.fetch({
          error: unexpectedError,
          success: fetchedCollCB
        });
      };
      fetchedCollCB = function(coll) {
        return restoredColl = coll;
      };
      runs(function() {
        return coll.create(point, {
          error: unexpectedError,
          success: createdModelCB
        });
      });
      waiter = function() {
        return restoredColl;
      };
      waitsFor(waiter, "The model should have been deleted", 1000);
      return runs(function() {
        return expect(restoredColl.length).toEqual(0);
      });
    });
  });

}).call(this);
